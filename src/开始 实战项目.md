##  normalize.css  [ˈnɔːməlaɪz]
    是一个可以定制的CSS文件，它让不同的浏览器在渲染网页元素的时候形式更统一。

    npm i normalize.css --save

##  dos
    cp 文件名   新名

    cp -r 文件夹名   新文件夹名

    cp -r index query  车次列表
                ticket 选择车票
                order  订单页

    ls 查看有哪些文件



##  config -> paths.js

    // 增加
    appQueryHtml: resolveApp('public/query.html'),
    appTicketHtml: resolveApp('public/ticket.html'),
    appQrderHtml: resolveApp('public/order.html'),

    // 修改路径 src/index => src/index/index
    appIndexJs: resolveModule(resolveApp, 'src/index/index'),

    // 增加
    appQueryJs: resolveModule(resolveApp, 'src/query/index'),
    appTicketJs: resolveModule(resolveApp, 'src/ticket/index'),
    appQrderJs: resolveModule(resolveApp, 'src/order/index'),



##  config -> webpack.config
  - entry: [] 改为: 对象 (其实就是单个的, 改成多个)


    // 原来的:
    entry:[ isEnvDevelopment && require.resolve('react-dev-utils/webpackHotDevClient'), paths.appIndexJs, ]filter(Boolean),

    // 现在的: 
    entry: {
      index: [paths.appIndexJs, isEnvDevelopment && require.resolve('react-dev-utils/webpackHotDevClient')].filter(Boolean),
      query: [paths.appQueryJs, isEnvDevelopment && require.resolve('react-dev-utils/webpackHotDevClient')].filter(Boolean),
      ticket: [paths.appTicketJs, isEnvDevelopment && require.resolve('react-dev-utils/webpackHotDevClient')].filter(Boolean),
      order: [paths.appOrderJs, isEnvDevelopment && require.resolve('react-dev-utils/webpackHotDevClient')].filter(Boolean),
    },  


  - 第二个修改位置

    // 先是增加 下面 2 句,  再是增加后面 一整个方法; new HtmlWebpackPlugin() 
    new HtmlWebpackPlugin(
        Object.assign(
          {},
          {
            inject: true,
            template: paths.appHtml,
            filename: 'index.html',  // 增加这 2 句
            chunks: ['index'],  // 增加这 2 句
          },
          isEnvProduction
            ? {
                minify: {
                  removeComments: true,
                  collapseWhitespace: true,
                  removeRedundantAttributes: true,
                  useShortDoctype: true,
                  removeEmptyAttributes: true,
                  removeStyleLinkTypeAttributes: true,
                  keepClosingSlash: true,
                  minifyJS: true,
                  minifyCSS: true,
                  minifyURLs: true,
                },
              }
            : undefined
        )
      ),


    // 再是增加后面 一整个方法; new HtmlWebpackPlugin(), 然后改下面的对应的三句;

    -> qurey
    template: paths.appHtml, => template: paths.appQureyHtml,
    filename: 'index.html',  => filename: 'query.html',
    chunks: ['index'],       => chunks: ['query'],

    -> ticket
    template: paths.appHtml, => template: paths.appTicketHtml,
    filename: 'index.html',  => filename: 'ticket.html',
    chunks: ['index'],       => chunks: ['ticket'],

    -> order
    template: paths.appHtml, => template: paths.appOrderHtml,
    filename: 'index.html',  => filename: 'order.html',
    chunks: ['index'],       => chunks: ['order'],

##  可以编译多个页面的工程 还要修改下面这处; npm run build
    webpack.config.js -> output: { static.js/bundle.js  改为 static.js/[name].js }


##  报错: Cannot read property 'filter' of undefined

	上面都修改后, 创建项目(npm run build) 报错, 做下面修改即可;

	解决方案:
		方案一: 删除 generate属性,保持与老版本生成的 create-react-app 生成的 ManifestPlugin 配置一致。

		方案二: 修改 entrypoints.main 中的 main 为你在 entry 中配置的项目首页的 key。我的 entry 配置中首页的 key 为 index ,因此可改为 entrypoints.index。


##  express
	mkdir train-mock
	cd train-mock
	npm init -y           // 穿建了一个 package.json 文件
	touch index.js

	npm i express --save


	-> index.js

		const express = require('express');
		const app = express();

		app.get('/', (request, response) => {
			response.status(200);
			response.send('hello express');
			response.end();
		});

		app.get('/rest', (request, response) => {
			response.json({
				result:1,
				msg: 'hello express'
			})
		})

		app.listen(4000); // 前面 5000 有被占用,改 4 3 都可以.

	运行:	train-mock tongle3000$ (根目录下) node index.js

 -  train-ticket -> package.json  
	加入 "proxy": "http://localhost:4000", (位置: "script"上面)

	保存, npm start, 

	chrome 浏览器 console 里输入: fetch('/rest')  -> 转 Network,点 rest 能看到 得到的数据;


##  Header.JSX
	npm i prop-types --save


##  bindActionCreators(actions, dispatch)   

    const mapDispatchToProps = (dispatch) => {
        return {
            handlJourney: bindActionCreators({exchangeFromTo,showCitySelector,}, dispatch),
        }
    }
    
    const cbsJourney = useMemo(() => { return handlJourney })


##  citys=[] 这里必须赋值空数组, 不然报错: Uncaught TypeError: Cannot read property 'map' of 
    const {title, citys = [], onSelect} = props; // citys=[] 这里必须赋值空数组   

##  onClick 回调写错: <li onClick={onSelect} key={name}>{name}</li>  报 input 显示[Object Object]

	onClick={() => onSelect(name)}  改为一个回调函数, 传入 name 城市名字;
	

##  跳转到固定位置 类似锚链接
    const toAlpha = useCallback(alpha) => {
      	document.querySelector(`[data-cate='${alpha}']`).scrollIntoView();
    }, []);

##	<AllLetters letterList={cityData.cityList} />  这里 letterList 与 cityData.cityList 进行绑定.

	只要取出 cityList 数组, 然后遍历它的 title 值就可以

	// 数组里的 title 字母 26个字母;
	const AllLetters = memo(function AllLetters(props) {
		const {letterList} = props;
		return (
			<ul>
				{
					letterList.map( list => {    //  每一项列表里的 进行循环, 
						return (                  // 取它的 title 值;
							<li key={list.title}>{list.title}</li>  
						)
					})
					
				}
			</ul>
		)
	})



##  钟点时间,前面补 0;
    npm i left-pad --save
        return startHours + ':00';  改为
        leftPad(startHours, 2, '0')  + ':00'; // 2 补成 2 位, '0' 补0;


##  拖动滑块, 就是响应 DOM 事件; ref   useRef
    const startHandle =useRef()
    const endHandle =useRef()

	jsx里引用
		ref={startHandle}
		ref={endHandle}
		ref={range}
	本身的作业,,触发重新渲染, 最好别用 usestate 来记录; 
	跨越组件渲染周期,来保存, 并且不会触发重新渲染组件, 还是 Ref; useRef 不禁能记录 DOM 节点, 还可以存储任何数据;

		const lastStartX = useRef();
		const lastEndX = useRef();

		const range = useRef();  // range  jsx 引用 ref={range}
		const rangeWidth = useRef();

	原则上 只监听 touch move 事件就行, 但touch move 横坐标值 必须从 touch start 获得, 所以,每个滑块要监听 2 个事件;
	touch start  touch move, 操作 dom 用 sueEffect(), .current才能获得 dom对象

		// 定义onStartTouchBegin
		function onStartTouchBegin(e) {
			const touch = e.targetTouches[0];
			lastStartX.current = touch.pageX;
		}

		function onEndTouchBegin(e) {
			const touch = e.targetTouches[0];
			lastEndX.current = touch.pageX;
		}
		
		// touch Move
		function onStartTouchMove(e) {
			const touch = e.targetTouches[0];
			const distance = touch.pageX - lastStartX.current;

			lastStartX.current = touch.pageX; // 开始位置 赋新值;

			setStart(start => start + (distance / rangeWidth.current) * 100)
		}

		function onEndTouchMove(e) {
			const touch = e.targetTouches[0];
			const distance = touch.pageX - lastEndX.current;

			lastEndX.current = touch.pageX; // 开始位置 赋新值;

			setEnd(end => end + (distance / rangeWidth.current) * 100)
		}
      
		// 副作用, 测量 range的宽度
		useEffect(() => {
			rangeWidth.current = parseFloat(
				window.getComputedStyle(range.current).width,
			)
		}, [])



	useEffect(() => {
		// 左边
		startHandle.current.addEventListener('touchStart', onStartTouchBegin, false); // 左边滑块 初始值
		startHandle.current.addEventListener('touchMove', onStartTouchMove, false);

		// 右边
		endHandle.current.addEventListener('touchStart', onEndTouchBegin, false); // 右边滑块 初始值
		endHandle.current.addEventListener('touchMove', onEndTouchMove, false);

		// 解绑, add 改成 remove
		return () => {
			// 左边
			startHandle.current.removeEventListener('touchStart', onStartTouchBegin, false);
			startHandle.current.addEventListener('touchMove', onStartTouchMove, false);

			// 右边
			endHandle.current.removeEventListener('touchStart', onEndTouchBegin, false);
			endHandle.current.removeEventListener('touchMove', onEndTouchMove, false);
		}
	}); // 不用传第二参数;







